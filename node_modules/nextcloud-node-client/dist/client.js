"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandStatus = exports.FileSystemFolder = exports.UploadFolderCommand = exports.UploadFilesCommand = exports.GetFilesRecursivelyCommand = exports.DownloadFolderCommand = exports.ShareItemType = exports.UserProperty = exports.UserGroup = exports.User = exports.RequestResponseLogEntry = exports.RequestResponseLog = exports.SharePermission = exports.Share = exports.Server = exports.FakeServer = exports.Tag = exports.FileSystemElement = exports.File = exports.Folder = exports.Environment = exports.ClientError = exports.Client = exports.UserGroupDoesNotExistError = exports.UserGroupDeletionFailedError = exports.UserGroupAlreadyExistsError = exports.UserUpdateError = exports.UserResendWelcomeEmailError = exports.UserCreateError = exports.UserAlreadyExistsError = exports.UserNotFoundError = exports.QueryOffsetError = exports.QueryLimitError = exports.OperationFailedError = exports.InsufficientPrivilegesError = exports.InvalidServiceResponseFormatError = exports.CommandAlreadyExecutedError = void 0;
// this must be the first
const dotenv_1 = require("dotenv");
dotenv_1.config();
const uploadFilesCommand_1 = __importDefault(require("./command/uploadFilesCommand"));
exports.UploadFilesCommand = uploadFilesCommand_1.default;
const uploadFolderCommand_1 = __importDefault(require("./command/uploadFolderCommand"));
exports.UploadFolderCommand = uploadFolderCommand_1.default;
const getFilesRecursivelyCommand_1 = __importDefault(require("./command/getFilesRecursivelyCommand"));
exports.GetFilesRecursivelyCommand = getFilesRecursivelyCommand_1.default;
const downloadFolderCommand_1 = __importDefault(require("./command/downloadFolderCommand"));
exports.DownloadFolderCommand = downloadFolderCommand_1.default;
const command_1 = require("./command/command");
Object.defineProperty(exports, "CommandStatus", { enumerable: true, get: function () { return command_1.CommandStatus; } });
const fast_xml_parser_1 = __importDefault(require("fast-xml-parser"));
const node_fetch_1 = require("node-fetch");
const path_1 = __importStar(require("path"));
const environment_1 = __importDefault(require("./environment"));
exports.Environment = environment_1.default;
const environmentVcapServices_1 = __importDefault(require("./environmentVcapServices"));
const error_1 = __importStar(require("./error"));
exports.ClientError = error_1.default;
Object.defineProperty(exports, "CommandAlreadyExecutedError", { enumerable: true, get: function () { return error_1.CommandAlreadyExecutedError; } });
Object.defineProperty(exports, "QueryLimitError", { enumerable: true, get: function () { return error_1.QueryLimitError; } });
Object.defineProperty(exports, "QueryOffsetError", { enumerable: true, get: function () { return error_1.QueryOffsetError; } });
Object.defineProperty(exports, "InsufficientPrivilegesError", { enumerable: true, get: function () { return error_1.InsufficientPrivilegesError; } });
Object.defineProperty(exports, "InvalidServiceResponseFormatError", { enumerable: true, get: function () { return error_1.InvalidServiceResponseFormatError; } });
Object.defineProperty(exports, "OperationFailedError", { enumerable: true, get: function () { return error_1.OperationFailedError; } });
Object.defineProperty(exports, "UserGroupAlreadyExistsError", { enumerable: true, get: function () { return error_1.UserGroupAlreadyExistsError; } });
Object.defineProperty(exports, "UserGroupDeletionFailedError", { enumerable: true, get: function () { return error_1.UserGroupDeletionFailedError; } });
Object.defineProperty(exports, "UserResendWelcomeEmailError", { enumerable: true, get: function () { return error_1.UserResendWelcomeEmailError; } });
Object.defineProperty(exports, "UserGroupDoesNotExistError", { enumerable: true, get: function () { return error_1.UserGroupDoesNotExistError; } });
Object.defineProperty(exports, "UserNotFoundError", { enumerable: true, get: function () { return error_1.UserNotFoundError; } });
Object.defineProperty(exports, "UserAlreadyExistsError", { enumerable: true, get: function () { return error_1.UserAlreadyExistsError; } });
Object.defineProperty(exports, "UserCreateError", { enumerable: true, get: function () { return error_1.UserCreateError; } });
Object.defineProperty(exports, "UserUpdateError", { enumerable: true, get: function () { return error_1.UserUpdateError; } });
const fakeServer_1 = __importDefault(require("./fakeServer"));
exports.FakeServer = fakeServer_1.default;
const file_1 = __importDefault(require("./file"));
exports.File = file_1.default;
const fileSystemElement_1 = __importDefault(require("./fileSystemElement"));
exports.FileSystemElement = fileSystemElement_1.default;
const fileSystemFolder_1 = __importDefault(require("./fileSystemFolder"));
exports.FileSystemFolder = fileSystemFolder_1.default;
const folder_1 = __importDefault(require("./folder"));
exports.Folder = folder_1.default;
const httpClient_1 = require("./httpClient");
const requestResponseLog_1 = __importDefault(require("./requestResponseLog"));
exports.RequestResponseLog = requestResponseLog_1.default;
const requestResponseLogEntry_1 = __importDefault(require("./requestResponseLogEntry"));
exports.RequestResponseLogEntry = requestResponseLogEntry_1.default;
const server_1 = __importDefault(require("./server"));
exports.Server = server_1.default;
const share_1 = __importStar(require("./share"));
exports.Share = share_1.default;
Object.defineProperty(exports, "SharePermission", { enumerable: true, get: function () { return share_1.SharePermission; } });
Object.defineProperty(exports, "ShareItemType", { enumerable: true, get: function () { return share_1.ShareItemType; } });
const tag_1 = __importDefault(require("./tag"));
exports.Tag = tag_1.default;
const userGroup_1 = __importDefault(require("./userGroup"));
exports.UserGroup = userGroup_1.default;
const user_1 = __importStar(require("./user"));
exports.User = user_1.default;
Object.defineProperty(exports, "UserProperty", { enumerable: true, get: function () { return user_1.UserProperty; } });
const logger_1 = __importDefault(require("./logger"));
const log = new logger_1.default();
/**
 * The nextcloud client is the root object to access the remote api of the nextcloud server.<br>
 */
class Client {
    /**
     * Creates a new instance of a nextcloud client.<br/>
     * Use the server to provide server connectivity information to the client.<br/>
     * (The FakeServer is only used for testing and code coverage)<br/><br/>
     * If the server is not provided the client tries to find the connectivity information
     * in the environment.<br/>
     * If a <b>VCAP_SERVICES</b> environment variable is available, the client tries to find
     * a service with the name <b>"nextcloud"</b> in the user-provides-services section.<br/>
     * If no VCAP_SERVICES are available, the client uses the following variables
     * from the envirnonment for the connectivity:<br/>
     * <ul>
     * <li>NEXTCLOUD_URL - the url of the nextcloud server</li>
     * <li>NEXTCLOUD_USERNAME - the user name</li>
     * <li>NEXTCLOUD_PASSWORD - the application password</li>
     * </ul>
     * @param server optional server information to connection to a nextcloud server
     * @constructor
     */
    constructor(server) {
        this.logRequestResponse = false;
        log.debug("constructor");
        this.nextcloudOrigin = "";
        this.nextcloudAuthHeader = "";
        this.nextcloudRequestToken = "";
        this.webDAVUrl = "";
        this.userId = "";
        // if no server is provided, try to get a server from VCAP_S environment "nextcloud" instance
        // If no VCAP_S environment exists try from environment
        if (!server) {
            try {
                const env = new environmentVcapServices_1.default("nextcloud");
                server = env.getServer();
            }
            catch (e) {
                const serverOptions = {
                    url: environment_1.default.getNextcloudUrl(),
                    basicAuth: {
                        username: environment_1.default.getUserName(),
                        password: environment_1.default.getPassword(),
                    },
                    logRequestResponse: environment_1.default.getRecordingActiveIndicator(),
                };
                server = new server_1.default(serverOptions);
            }
        }
        if (server instanceof server_1.default) {
            this.proxy = server.proxy;
            log.debug("constructor: url ", server.url);
            if (server.url.indexOf(Client.webDavUrlPath) === -1) {
                if (server.url.slice(-1) === "/") {
                    server.url = server.url.slice(0, -1);
                }
                server.url = server.url + Client.webDavUrlPath;
            }
            this.nextcloudOrigin = server.url.substr(0, server.url.indexOf(Client.webDavUrlPath));
            log.debug("constructor: nextcloud url ", this.nextcloudOrigin);
            this.userId = server.basicAuth.username;
            this.nextcloudAuthHeader = "Basic " + Buffer.from(server.basicAuth.username + ":" + server.basicAuth.password).toString("base64");
            this.nextcloudRequestToken = "";
            if (server.url.slice(-1) === "/") {
                this.webDAVUrl = server.url.slice(0, -1);
            }
            else {
                this.webDAVUrl = server.url;
            }
            this.logRequestResponse = server.logRequestResponse;
            const options = {
                authorizationHeader: this.nextcloudAuthHeader,
                logRequestResponse: this.logRequestResponse,
                origin: this.nextcloudOrigin,
                proxy: this.proxy,
            };
            this.httpClient = new httpClient_1.HttpClient(options);
        }
        if (server instanceof fakeServer_1.default) {
            this.fakeServer = server;
            this.webDAVUrl = "https://fake.server" + Client.webDavUrlPath;
        }
    }
    /**
     * returns the used and free quota of the nextcloud account
     */
    getQuota() {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getQuota");
            const requestInit = {
                method: "PROPFIND",
            };
            const response = yield this.getHttpResponse(this.webDAVUrl + "/", requestInit, [207], { description: "Client get quota" });
            const properties = yield this.getPropertiesFromWebDAVMultistatusResponse(response, Client.webDavUrlPath + "/");
            let quota = null;
            for (const prop of properties) {
                if (prop["quota-available-bytes"]) {
                    quota = {
                        available: "unlimited",
                        used: prop["quota-used-bytes"],
                    };
                    if (prop["quota-available-bytes"] > 0) {
                        quota.available = prop["quota-available-bytes"];
                    }
                }
            }
            if (!quota) {
                log.debug("Error, quota not available: ", JSON.stringify(properties, null, 4));
                throw new error_1.default(`Error, quota not available`, "ERR_QUOTA_NOT_AVAILABLE");
            }
            log.debug("getQuota =", quota);
            return quota;
        });
    }
    // ***************************************************************************************
    // tags
    // ***************************************************************************************
    /**
     * creates a new tag, if not already existing
     * this function will fail with http 403 if the user does not have admin privileges
     * @param tagName the name of the tag
     * @returns tagId
     */
    createTag(tagName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("createTag");
            let tag;
            // is the tag already existing?
            tag = yield this.getTagByName(tagName);
            if (tag) {
                return tag;
            }
            // tag does not exist, create tag
            const requestInit = {
                body: `{ "name": "${tagName}", "userVisible": true, "userAssignable": true, "canAssign": true }`,
                headers: new node_fetch_1.Headers({ "Content-Type": "application/json" }),
                method: "POST",
            };
            const response = yield this.getHttpResponse(this.nextcloudOrigin + "/remote.php/dav/systemtags/", requestInit, [201], { description: "Tag create" });
            const tagString = response.headers.get("Content-Location");
            log.debug("createTag new tagId " + tagString + " tagName " + tagName);
            if (tagString === "" || tagString === null) {
                throw new error_1.default(`Error, tag with name '${tagName}' could not be created`, "ERR_TAG_CREATE_FAILED");
            }
            // the number id of the tag is the last element in the id (path)
            const tagId = this.getTagIdFromHref(tagString);
            tag = new tag_1.default(this, tagId, tagName, true, true, true);
            return tag;
        });
    }
    /**
     * returns a tag identified by the name or null if not found
     * @param tagName the name of the tag
     * @returns tag or null
     */
    getTagByName(tagName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getTag");
            const tags = yield this.getTags();
            for (const tag of tags) {
                if (tag.name === tagName) {
                    return tag;
                }
            }
            return null;
        });
    }
    /**
     * returns a tag identified by the id or null if not found
     * @param tagId the id of the tag
     * @returns tag or null
     */
    getTagById(tagId) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getTagById");
            const tags = yield this.getTags();
            for (const tag of tags) {
                if (tag.id === tagId) {
                    return tag;
                }
            }
            return null;
        });
    }
    /**
     * deletes the tag by id
     * this function will fail with http 403 if the user does not have admin privileges
     * @param tagId the id of the tag like "/remote.php/dav/systemtags/234"
     */
    deleteTag(tagId) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("deleteTag tagId: ", tagId);
            const requestInit = {
                method: "DELETE",
            };
            const response = yield this.getHttpResponse(`${this.nextcloudOrigin}/remote.php/dav/systemtags/${tagId}`, requestInit, [204, 404], { description: "Tag delete" });
        });
    }
    /**
     * deletes all visible assignable tags
     * @throws Error
     */
    deleteAllTags() {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("deleteAllTags");
            const tags = yield this.getTags();
            for (const tag of tags) {
                // log.debug("deleteAllTags tag: ", tag);
                yield tag.delete();
            }
        });
    }
    /**
     * returns a list of tags
     * @returns array of tags
     */
    getTags() {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getTags PROPFIND " + this.nextcloudOrigin + "/remote.php/dav/systemtags/");
            const requestInit = {
                body: `<?xml version="1.0"?>
            <d:propfind  xmlns:d="DAV:" xmlns:oc="http://owncloud.org/ns">
              <d:prop>
                <oc:id />
                <oc:display-name />
                <oc:user-visible />
                <oc:user-assignable />
                <oc:can-assign />
              </d:prop>
            </d:propfind>`,
                method: "PROPFIND",
            };
            const relUrl = `/remote.php/dav/systemtags/`;
            const response = yield this.getHttpResponse(this.nextcloudOrigin + relUrl, requestInit, [207], { description: "Tags get" });
            const properties = yield this.getPropertiesFromWebDAVMultistatusResponse(response, relUrl + "/*");
            const tags = [];
            for (const prop of properties) {
                tags.push(new tag_1.default(this, this.getTagIdFromHref(prop._href), prop["display-name"], prop["user-visible"], prop["user-assignable"], prop["can-assign"]));
            }
            return tags;
        });
    }
    /**
     * returns the list of tag names and the tag ids
     * @param fileId the id of the file
     */
    getTagsOfFile(fileId) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getTagsOfFile");
            const requestInit = {
                body: `<?xml version="1.0"?>
            <d:propfind  xmlns:d="DAV:" xmlns:oc="http://owncloud.org/ns">
              <d:prop>
                <oc:id />
                <oc:display-name />
                <oc:user-visible />
                <oc:user-assignable />
                <oc:can-assign />
              </d:prop>
            </d:propfind>`,
                method: "PROPFIND",
            };
            const relUrl = `/remote.php/dav/systemtags-relations/files/${fileId}`;
            const response = yield this.getHttpResponse(`${this.nextcloudOrigin}${relUrl}`, requestInit, [207], { description: "File get tags" });
            const properties = yield this.getPropertiesFromWebDAVMultistatusResponse(response, relUrl + "/*");
            const tagMap = new Map();
            for (const prop of properties) {
                tagMap.set(prop["display-name"], prop.id);
            }
            log.debug("tags of file ", tagMap);
            return tagMap;
        });
    }
    /**
     * removes the tag from the file
     * @param fileId the file id
     * @param tagId the tag id
     */
    removeTagOfFile(fileId, tagId) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("removeTagOfFile tagId: " + tagId + " fileId:" + fileId);
            const requestInit = {
                method: "DELETE",
            };
            const response = yield this.getHttpResponse(`${this.nextcloudOrigin}/remote.php/dav/systemtags-relations/files/${fileId}/${tagId}`, requestInit, [204, 404], { description: "File remove tag" });
            return;
        });
    }
    /**
     * returns the id of the file or -1 of not found
     * @returns id of the file or -1 if not found
     */
    getFileId(fileUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getFileId");
            const requestInit = {
                body: `
            <d:propfind  xmlns:d="DAV:" xmlns:oc="http://owncloud.org/ns" xmlns:nc="http://nextcloud.org/ns">
              <d:prop>
                  <oc:fileid />
              </d:prop>
            </d:propfind>`,
                method: "PROPFIND",
            };
            const response = yield this.getHttpResponse(fileUrl, requestInit, [207], { description: "File get id" });
            const properties = yield this.getPropertiesFromWebDAVMultistatusResponse(response, "");
            for (const prop of properties) {
                if (prop.fileid) {
                    return prop.fileid;
                }
            }
            log.debug("getFileId no file id found for " + fileUrl);
            return -1;
        });
    }
    getFolderContents(folderName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getFolderContents");
            const requestInit = {
                body: `<?xml version="1.0"?>
            <d:propfind  xmlns:d="DAV:" xmlns:oc="http://owncloud.org/ns" xmlns:nc="http://nextcloud.org/ns" xmlns:ocs="http://open-collaboration-services.org/ns">
              <d:prop>
                <d:getlastmodified />
                <d:getetag />
                <d:getcontenttype />
                <d:resourcetype />
                <oc:fileid />
                <oc:permissions />
                <oc:size />
                <d:getcontentlength />
                <nc:has-preview />
                <nc:mount-type />
                <nc:is-encrypted />
                <ocs:share-permissions />
                <oc:tags />
                <oc:favorite />
                <oc:comments-unread />
                <oc:owner-id />
                <oc:owner-display-name />
                <oc:share-types />
              </d:prop>
            </d:propfind>`,
                method: "PROPFIND",
            };
            const url = `${this.webDAVUrl}${folderName}`;
            const response = yield this.getHttpResponse(url, requestInit, [207], { description: "Folder get contents" });
            const folderContents = [];
            let properties;
            properties = yield this.getPropertiesFromWebDAVMultistatusResponse(response, "");
            // tslint:disable-next-line:no-empty
            for (const prop of properties) {
                let fileName = decodeURI(prop._href.substr(prop._href.indexOf(Client.webDavUrlPath) + 18));
                if (fileName.endsWith("/")) {
                    fileName = fileName.slice(0, -1);
                }
                if ((url + "/").endsWith(decodeURI(prop._href))) {
                    continue;
                }
                const folderContentsEntry = {};
                folderContentsEntry.lastmod = prop.getlastmodified;
                folderContentsEntry.fileid = prop.fileid;
                folderContentsEntry.basename = fileName.split("/").reverse()[0];
                folderContentsEntry.filename = fileName;
                if (prop.getcontenttype) {
                    folderContentsEntry.mime = prop.getcontenttype;
                    folderContentsEntry.size = prop.getcontentlength;
                    folderContentsEntry.type = "file";
                }
                else {
                    folderContentsEntry.type = "directory";
                }
                // if (folderContentsEntry.basename !== "") {
                folderContents.push(folderContentsEntry);
                // }
            }
            // log.debug("folderContentsEntry ", JSON.stringify(folderContents, null, 4));
            return folderContents;
        });
    }
    /**
     * creates a folder and all parent folders in the path if they do not exist
     * @param folderName name of the folder /folder/subfolder/subfolder
     * @returns a folder object
     */
    createFolder(folderName) {
        return __awaiter(this, void 0, void 0, function* () {
            folderName = this.sanitizeFolderName(folderName);
            log.debug("createFolder: folderName=", folderName);
            const parts1 = folderName.split("/");
            for (const p of parts1) {
                if ((p) === "." || p === "..") {
                    throw new error_1.default(`Error creating folder, folder name "${folderName}" invalid`, "ERR_CREATE_FOLDER_INVALID_FOLDER_NAME");
                }
            }
            let folder;
            folder = yield this.getFolder(folderName);
            if (folder) {
                log.debug("createFolder: folder already available ", folder.name);
                return folder;
            }
            else {
                // try to do a simple create with the complete path
                try {
                    log.debug("createFolder: folder = ", folderName);
                    yield this.createFolderInternal(folderName);
                }
                catch (e) {
                    // create all folders in the path
                    const parts = folderName.split("/");
                    parts.shift();
                    let folderPath = "";
                    log.debug("createFolder: parts = ", parts);
                    for (const part of parts) {
                        log.debug("createFolder: part = ", part);
                        folderPath += "/" + part;
                        folder = yield this.getFolder(folderPath);
                        if (folder === null) {
                            log.debug("createFolder: folder not available");
                            // folder not  available
                            log.debug("createFolder: folder = ", folderPath);
                            yield this.createFolderInternal(folderPath);
                        }
                        else {
                            log.debug("createFolder: folder already available ", folderPath);
                        }
                    }
                }
            }
            folder = yield this.getFolder(folderName);
            if (folder) {
                log.debug("createFolder: new folder ", folder.name);
                return folder;
            }
            else {
                throw new error_1.default(`Error creating folder, folder name "${folderName}"
            `, "ERR_CREATE_FOLDER_FAILED");
            }
        });
    }
    /**
     * deletes a file
     * @param fileName name of folder "/f1/f2/f3/x.txt"
     */
    deleteFile(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.webDAVUrl + fileName;
            log.debug("deleteFile ", url);
            const requestInit = {
                method: "DELETE",
            };
            try {
                yield this.getHttpResponse(url, requestInit, [204], { description: "File delete" });
            }
            catch (err) {
                log.debug("Error in deleteFile ", err.message, requestInit.method, url);
                throw err;
            }
        });
    }
    /**
     * deletes a folder
     * @param folderName name of folder "/f1/f2/f3"
     */
    deleteFolder(folderName) {
        return __awaiter(this, void 0, void 0, function* () {
            folderName = this.sanitizeFolderName(folderName);
            log.debug("deleteFolder:");
            const folder = yield this.getFolder(folderName);
            if (folder) {
                yield this.deleteFile(folderName);
            }
        });
    }
    /**
     * get the root folder object
     * @returns {Promise<Folder>} the root folder
     */
    getRootFolder() {
        return new folder_1.default(this, "/", "", "");
    }
    /**
     * returns an array of file system objects that have all given tags assigned (AND)
     * @param {Tag[]} tags array of tags
     * @async
     * @returns {Promise<FileSystemElement[]>} returns an array of file system objects
     */
    getFileSystemElementByTags(tags) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getFileSystemElementByTags ", tags.join(", "));
            let filterRule = "";
            for (const tag of tags) {
                filterRule += `<oc:systemtag>${tag.id}</oc:systemtag>`;
            }
            const urlSuffix = `/remote.php/dav/files/`;
            const url = `${this.nextcloudOrigin}${urlSuffix}${this.userId}`;
            const body = `<?xml version="1.0"?>
        <oc:filter-files  xmlns:d=\"DAV:\" xmlns:oc=\"http://owncloud.org/ns\" xmlns:nc=\"http://nextcloud.org/ns\" xmlns:ocs=\"http://open-collaboration-services.org/ns\">
           <d:prop>
              <d:getcontenttype />
              <oc:fileid />
           </d:prop>
           <oc:filter-rules>
                ${filterRule}
           </oc:filter-rules>
        </oc:filter-files>`;
            const requestInit = {
                body,
                // headers: new Headers({ Depth: "0" }),
                method: "REPORT",
            };
            let response;
            try {
                response = yield this.getHttpResponse(url, requestInit, [207], { description: "Get FileSystemElements by tags" });
            }
            catch (err) {
                log.debug("Error in stat ", err.message, requestInit.method, url);
                throw err;
            }
            const result = [];
            let properties = [];
            try {
                properties = yield this.getPropertiesFromWebDAVMultistatusResponse(response, "");
            }
            catch (e) {
                return result;
            }
            for (const prop of properties) {
                let fse = null;
                let name = prop._href;
                // remove the first two elements from the path
                name = name.replace(urlSuffix, "");
                const a = name.split("/");
                a.shift();
                name = "/" + a.join("/");
                // console.log(name);
                if (prop.getcontenttype) {
                    fse = yield this.getFile(name);
                }
                else {
                    fse = yield this.getFolder(name);
                }
                result.push(fse);
            }
            return result;
        });
    }
    /**
     * get a folder object from a path string
     * @param {string} folderName Name of the folder like "/company/branches/germany"
     * @returns {Promise<Folder | null>} null if the folder does not exist or an folder object
     */
    getFolder(folderName) {
        return __awaiter(this, void 0, void 0, function* () {
            folderName = this.sanitizeFolderName(folderName);
            log.debug("getFolder", folderName);
            // return root folder
            if (folderName === "/" || folderName === "") {
                return this.getRootFolder();
            }
            try {
                const stat = yield this.stat(folderName);
                log.debug(": SUCCESS!!");
                if (stat.type !== "file") {
                    return new folder_1.default(this, stat.filename.replace(/\\/g, "/"), stat.basename, stat.lastmod, stat.fileid);
                }
                else {
                    log.debug("getFolder: found object is file not a folder");
                    return null;
                }
            }
            catch (e) {
                log.debug("getFolder: exception occurred calling stat ", e.message);
                return null;
            }
        });
    }
    /**
     * get a array of folders from a folder path string
     * @param folderName Name of the folder like "/company/branches/germany"
     * @returns array of folder objects
     */
    getSubFolders(folderName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getSubFolders: folder ", folderName);
            const folders = [];
            folderName = this.sanitizeFolderName(folderName);
            const folderElements = yield this.Contents(folderName, true);
            for (const folderElement of folderElements) {
                log.debug("getSubFolders: adding subfolders ", folderElement.filename);
                folders.push(new folder_1.default(this, folderElement.filename.replace(/\\/g, "/"), folderElement.basename, folderElement.lastmod, folderElement.fileid));
            }
            return folders;
        });
    }
    /**
     * get files of a folder
     * @param {string} folderName Name of the folder like "/company/branches/germany"
     * @param {FolderGetFilesOptions} options options for filtering and paging
     * @returns array of file objects
     */
    getFiles(folderName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getFiles: folder ", folderName);
            const files = [];
            folderName = this.sanitizeFolderName(folderName);
            const fileElements = yield this.Contents(folderName, false);
            for (const folderElement of fileElements) {
                log.debug("getFiles: adding file ", folderElement.filename);
                // log.debug("getFiles: adding file ", folderElement);
                let file = new file_1.default(this, folderElement.filename.replace(/\\/g, "/"), folderElement.basename, folderElement.lastmod, folderElement.size, folderElement.mime, folderElement.fileid);
                if (options && options.filterFile) {
                    file = options.filterFile(file);
                }
                if (file) {
                    files.push(file);
                }
            }
            return files;
        });
    }
    /**
     * create a new file of overwrites an existing file
     * @param fileName the file name /folder1/folder2/filename.txt
     * @param data the buffer object
     */
    createFile(fileName, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (fileName.startsWith("./")) {
                fileName = fileName.replace("./", "/");
            }
            const baseName = path_1.default.basename(fileName);
            const folderName = path_1.default.dirname(fileName);
            log.debug(`createFile folder name ${folderName} base name ${baseName}`);
            // ensure that we have a folder
            yield this.createFolder(folderName);
            yield this.putFileContents(fileName, data);
            let file;
            file = yield this.getFile(fileName);
            if (!file) {
                throw new error_1.default(`Error creating file, file name "${fileName}"`, "ERR_CREATE_FILE_FAILED");
            }
            return file;
        });
    }
    /**
     * returns a nextcloud file object
     * @param fileName the full file name /folder1/folder2/file.pdf
     */
    getFile(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getFile fileName = ", fileName);
            try {
                const stat = yield this.stat(fileName);
                log.debug(": SUCCESS!!");
                if (stat.type === "file") {
                    return new file_1.default(this, stat.filename.replace(/\\/g, "/"), stat.basename, stat.lastmod, stat.size, stat.mime || "", stat.fileid || -1);
                }
                else {
                    log.debug("getFile: found object is a folder not a file");
                    return null;
                }
            }
            catch (e) {
                log.debug("getFile: exception occurred calling stat ", e.message);
                return null;
            }
        });
    }
    /**
     * renames the file or moves it to an other location
     * @param sourceFileName source file name
     * @param targetFileName target file name
     */
    moveFile(sourceFileName, targetFileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.webDAVUrl + sourceFileName;
            const destinationUrl = this.webDAVUrl + targetFileName;
            log.debug("moveFile from '" + url + "' to '" + destinationUrl + "'");
            const requestInit = {
                headers: new node_fetch_1.Headers({ Destination: destinationUrl }),
                method: "MOVE",
            };
            try {
                yield this.getHttpResponse(url, requestInit, [201], { description: "File move" });
            }
            catch (err) {
                log.debug(`Error in move file ${err.message} ${requestInit.method} source: ${url} destination: ${destinationUrl}`);
                throw new error_1.default("Error: moving file failed: source=" + sourceFileName + " target=" + targetFileName + " - " + err.message, "ERR_FILE_MOVE_FAILED");
            }
            const targetFile = yield this.getFile(targetFileName);
            if (!targetFile) {
                throw new error_1.default("Error: moving file failed: source=" + sourceFileName + " target=" + targetFileName, "ERR_FILE_MOVE_FAILED");
            }
            return targetFile;
        });
    }
    /**
     * renames the folder or moves it to an other location
     * @param sourceFolderName source folder name
     * @param tarName target folder name
     */
    moveFolder(sourceFolderName, tarName) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.webDAVUrl + sourceFolderName;
            const destinationUrl = this.webDAVUrl + tarName;
            log.debug(`moveFolder from '${url}' to '${destinationUrl}'`);
            const requestInit = {
                headers: new node_fetch_1.Headers({ Destination: destinationUrl }),
                method: "MOVE",
            };
            try {
                yield this.getHttpResponse(url, requestInit, [201], { description: "Folder move" });
            }
            catch (err) {
                log.debug(`Error in move folder ${err.message} ${requestInit.method} source: ${url} destination: ${destinationUrl}`);
                throw new error_1.default("Error: moving folder failed: source=" + sourceFolderName + " target=" + tarName + " - " + err.message, "ERR_FOLDER_MOVE_FAILED");
            }
            const tar = yield this.getFolder(tarName);
            if (!tar) {
                throw new error_1.default("Error: moving folder failed: source=" + sourceFolderName + " target=" + tarName, "ERR_FOLDER_MOVE_FAILED");
            }
            return tar;
        });
    }
    /**
     * returns the content of a file
     * @param fileName name of the file /d1/file1.txt
     * @returns Buffer with file content
     */
    getContent(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.webDAVUrl + fileName;
            log.debug("getContent GET ", url);
            const requestInit = {
                method: "GET",
            };
            let response;
            try {
                response = yield this.getHttpResponse(url, requestInit, [200], { description: "File get content" });
            }
            catch (err) {
                log.debug(`Error getContent ${url} - error ${err.message}`);
                throw err;
            }
            return Buffer.from(yield response.buffer());
        });
    }
    /**
     * returns the content of a file
     * @param fileName name of the file /d1/file1.txt
     * @returns Buffer with file content
     */
    pipeContentStream(fileName, destination) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.webDAVUrl + fileName;
            log.debug("getContent GET ", url);
            const requestInit = {
                method: "GET",
            };
            let response;
            try {
                response = yield this.getHttpResponse(url, requestInit, [200], { description: "File pipe content stream" });
            }
            catch (err) {
                log.debug(`Error getContent ${url} - error ${err.message}`);
                throw err;
            }
            response.body.pipe(destination);
        });
    }
    /**
     * returns the link to a file for downloading
     * @param fileName name of the file /folder1/folder1.txt
     * @returns url
     */
    getLink(fileName) {
        log.debug("getLink of ", fileName);
        return this.webDAVUrl + fileName;
    }
    /**
     * returns the url to the file in the nextcloud UI
     * @param fileId the id of the file
     */
    getUILink(fileId) {
        log.debug("getUILink of ", fileId);
        return `${this.nextcloudOrigin}/apps/files/?fileid=${fileId}`;
    }
    /**
     * adds a tag to a file or folder
     * if the tag does not exist, it is automatically created
     * if the tag is created, the user must have damin privileges
     * @param fileId the id of the file
     * @param tagName the name of the tag
     * @returns nothing
     * @throws Error
     */
    addTagToFile(fileId, tagName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug(`addTagToFile file: "${fileId}" tag: "${tagName}"`);
            const tag = yield this.createTag(tagName);
            if (!tag.canAssign) {
                throw new error_1.default(`Error: No permission to assign tag "${tagName}" to file. Tag is not assignable`, "ERR_TAG_NOT_ASSIGNABLE");
            }
            const addTagBody = {
                canAssign: tag.canAssign,
                id: tag.id,
                name: tag.name,
                userAssignable: tag.assignable,
                userVisible: tag.visible,
            };
            const requestInit = {
                body: JSON.stringify(addTagBody, null, 4),
                headers: new node_fetch_1.Headers({ "Content-Type": "application/json" }),
                method: "PUT",
            };
            yield this.getHttpResponse(`${this.nextcloudOrigin}/remote.php/dav/systemtags-relations/files/${fileId}/${tag.id}`, requestInit, [201, 409], { description: "File add tag" }); // created or conflict
        });
    }
    // ***************************************************************************************
    // activity
    // ***************************************************************************************
    /*
    @todo to be refactored to eventing

    public async getActivities(): Promise<string[]> {
        const result: string[] = [];
        const requestInit: RequestInit = {
            headers: new Headers({ "ocs-apirequest": "true" }),
            method: "GET",
        };

        const response: Response = await this.getHttpResponse(
            this.nextcloudOrigin + "/ocs/v2.php/apps/activity/api/v2/activity/files?format=json&previews=false&since=97533",
            requestInit,
            [200],
            { description: "Activities get" });

        const responseObject: any = await response.json();
        // @todo

        for (const res of responseObject.ocs.data) {
            log.debug(JSON.stringify({
                acivityId: res.activity_id,
                objects: res.objects,
                type: res.type,
            }, null, 4));
        }

        // log.debug("getActivities: responseObject ", JSON.stringify(responseObject, null, 4));

        return result;
    }
*/
    // ***************************************************************************************
    // comments
    // ***************************************************************************************
    /**
     * adds a comment to a file
     * @param fileId the id of the file
     * @param comment the comment to be added to the file
     */
    addCommentToFile(fileId, comment) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug(`addCommentToFile file:"${fileId}" comment:"${comment}"`);
            const addCommentBody = {
                actorType: "users",
                message: comment,
                objectType: "files",
                verb: "comment",
            };
            const requestInit = {
                body: JSON.stringify(addCommentBody, null, 4),
                headers: new node_fetch_1.Headers({ "Content-Type": "application/json" }),
                method: "POST",
            };
            yield this.getHttpResponse(`${this.nextcloudOrigin}/remote.php/dav/comments/files/${fileId}`, requestInit, [201], { description: "File add comment" }); // created
        });
    }
    /**
     * returns comments of a file / folder
     * @param fileId the id of the file / folder
     * @param top number of comments to return
     * @param skip the offset
     * @returns array of comment strings
     * @throws Exception
     */
    getFileComments(fileId, top, skip) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getFileComments fileId: ", fileId);
            if (!top) {
                top = 30;
            }
            if (!skip) {
                skip = 0;
            }
            const requestInit = {
                body: `<?xml version="1.0" encoding="utf-8" ?>
                    <oc:filter-comments xmlns:D="DAV:" xmlns:oc="http://owncloud.org/ns">
                        <oc:limit>${top}</oc:limit>
                        <oc:offset>${skip}</oc:offset>
                    </oc:filter-comments>`,
                method: "REPORT",
            };
            const response = yield this.getHttpResponse(`${this.nextcloudOrigin}/remote.php/dav/comments/files/${fileId}`, requestInit, [207], { description: "File get comments" });
            const properties = yield this.getPropertiesFromWebDAVMultistatusResponse(response, "");
            const comments = [];
            for (const prop of properties) {
                comments.push(prop.message);
            }
            return comments;
        });
    }
    /**
     * returns system information about the nextcloud server and the nextcloud client
     */
    getSystemInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const response = yield this.getHttpResponse(this.nextcloudOrigin + "/ocs/v2.php/apps/serverinfo/api/v1/info", requestInit, [200], { description: "SystemInfo get" });
            const rawResult = yield response.json();
            // validate the raw result
            let system = {};
            let storage = {};
            let shares = {};
            let server = {};
            let activeUsers = {};
            if (rawResult && rawResult.ocs && rawResult.ocs.data) {
                if (rawResult.ocs.data.nextcloud) {
                    if (rawResult.ocs.data.nextcloud.system) {
                        system = rawResult.ocs.data.nextcloud.system;
                    }
                    else {
                        throw new error_1.default("Fatal Error: nextcloud data.nextcloud.system missing", "ERR_SYSTEM_INFO_MISSING_DATA");
                    }
                    if (rawResult.ocs.data.nextcloud.storage) {
                        storage = rawResult.ocs.data.nextcloud.storage;
                    }
                    else {
                        throw new error_1.default("Fatal Error: nextcloud data.nextcloud.storage missing", "ERR_SYSTEM_INFO_MISSING_DATA");
                    }
                    if (rawResult.ocs.data.nextcloud.shares) {
                        shares = rawResult.ocs.data.nextcloud.shares;
                    }
                    else {
                        throw new error_1.default("Fatal Error: nextcloud data.nextcloud.shares missing", "ERR_SYSTEM_INFO_MISSING_DATA");
                    }
                }
                else {
                    throw new error_1.default("Fatal Error: nextcloud data.nextcloud missing", "ERR_SYSTEM_INFO_MISSING_DATA");
                }
                if (rawResult.ocs.data.server) {
                    server = rawResult.ocs.data.server;
                }
                else {
                    throw new error_1.default("Fatal Error: nextcloud data.server missing", "ERR_SYSTEM_INFO_MISSING_DATA");
                }
                if (rawResult.ocs.data.activeUsers) {
                    activeUsers = rawResult.ocs.data.activeUsers;
                }
                else {
                    throw new error_1.default("Fatal Error: nextcloud data.activeUsers missing", "ERR_SYSTEM_INFO_MISSING_DATA");
                }
            }
            else {
                throw new error_1.default("Fatal Error: nextcloud system data missing", "ERR_SYSTEM_INFO_MISSING_DATA");
            }
            const result = {
                activeUsers,
                nextcloud: {
                    shares,
                    storage,
                    system,
                },
                nextcloudClient: {
                    version: require("../package.json").version,
                },
                server,
            };
            return result;
        });
    }
    getSystemBasicData() {
        return __awaiter(this, void 0, void 0, function* () {
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const response = yield this.getHttpResponse(this.nextcloudOrigin + "/ocs/v2.php/apps/serverinfo/api/v1/basicdata", requestInit, [200], { description: "System Basic Data get" });
            const rawResult = yield response.json();
            // console.log("Basic Data\n", JSON.stringify(rawResult));
            let result;
            if (rawResult &&
                rawResult.ocs &&
                rawResult.ocs.data &&
                rawResult.ocs.data.servertime &&
                rawResult.ocs.data.uptime &&
                rawResult.ocs.data.timeservers) {
                result = {
                    serverTimeString: rawResult.ocs.data.servertime.replace("\n", ""),
                    uptimeString: rawResult.ocs.data.uptime.replace("\n", ""),
                    timeServersString: rawResult.ocs.data.timeservers.trim(),
                };
            }
            else {
                throw new error_1.default("Fatal Error: nextcloud basic data missing", "ERR_SYSTEM_INFO_MISSING_DATA");
            }
            return result;
        });
    }
    // ***************************************************************************************
    // user management
    // ***************************************************************************************
    // ***************************************************************************************
    // user group
    // spec: https://docs.nextcloud.com/server/latest/admin_manual/configuration_user/instruction_set_for_groups.html
    // ***************************************************************************************
    /**
     * returns a list of user groups
     * @param search string
     * @param limit number
     * @param offset number
     * @returns list of user groups
     * @throws QueryLimitError
     * @throws QueryOffsetError
     */
    getUserGroups(search, limit, offset) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getUserGroups");
            const userGroupIds = yield this.getUserGroupIds(search, limit, offset);
            const userGroups = [];
            for (const userGroupId of userGroupIds) {
                userGroups.push(new userGroup_1.default(this, userGroupId));
            }
            return userGroups;
        });
    }
    /**
     * returns a list of user groups
     * @param search string
     * @param limit number
     * @param offset number
     * @returns list of user groups
     * @throws QueryLimitError
     * @throws QueryOffsetError
     */
    getUserGroupIds(search, limit, offset) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getUserGroupIds");
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            let url = this.getOcsUrl(`/groups`);
            const queryParameter = [];
            if (search) {
                queryParameter.push(`search=${search}`);
            }
            if (limit) {
                if (limit < 1) {
                    throw new error_1.QueryLimitError("The limit must be larger than 0");
                }
                queryParameter.push(`limit=${limit}`);
            }
            if (offset) {
                if (offset < 1) {
                    throw new error_1.QueryOffsetError("The offset must be larger than 0");
                }
                queryParameter.push(`offset=${offset}`);
            }
            if (queryParameter.join("&").length > 1) {
                url += "?" + queryParameter.join("&");
            }
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: "User Groups get" });
            const rawResult = yield response.json();
            /*
            {
              ocs: {
                meta: {
                  status: 'ok',
                  statuscode: 100,
                  message: 'OK',
                  totalitems: '',
                  itemsperpage: ''
                },
                data: { groups: ["g1", "g2"] }
              }
            }
            */
            const userGroups = [];
            if (rawResult.ocs &&
                rawResult.ocs.data &&
                rawResult.ocs.data.groups) {
                log.debug("groups", rawResult.ocs.data.groups);
                rawResult.ocs.data.groups.forEach((value) => {
                    // userGroups.push(new UserGroup(this, value));
                    userGroups.push(value);
                });
            }
            return userGroups;
        });
    }
    /**
     * get user group
     * @param id string
     * @returns Promise<UserGroup|null>
     */
    getUserGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const userGroups = yield this.getUserGroups(id);
            if (userGroups[0]) {
                return userGroups[0];
            }
            return null;
        });
    }
    /**
     * returns a list of user ids that are members of the user group
     * @param id string
     * @returns list of member user ids
     * @throws [UserGroupDoesNotExistError}
     */
    getUserGroupMembers(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getUserGroupMembers");
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const url = this.getOcsUrl(`/groups/${id}`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: "User group get members" });
            const rawResult = yield response.json();
            const userIds = [];
            if (this.getOcsMetaStatus(rawResult).code === 404) {
                throw new error_1.UserGroupDoesNotExistError(`User Group ${id} does not exist`);
            }
            if (rawResult.ocs &&
                rawResult.ocs.data &&
                rawResult.ocs.data.users) {
                log.debug("members", rawResult.ocs.data.users);
                rawResult.ocs.data.users.forEach((value) => {
                    userIds.push(value);
                });
            }
            return userIds;
        });
    }
    /**
     * returns a list of user ids that are subadmins of the user group
     * @param id string
     * @returns list of subadmin user ids
     * @throws [UserGroupDoesNotExistError}
     */
    getUserGroupSubadmins(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getUserGroupsubadmins");
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const url = this.getOcsUrl(`/groups/${id}/subadmins`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: "User group get subadmins" });
            const rawResult = yield response.json();
            const userIds = [];
            if (this.getOcsMetaStatus(rawResult).code === 101) {
                throw new error_1.UserGroupDoesNotExistError(`User Group ${id} does not exist`);
            }
            if (rawResult.ocs &&
                rawResult.ocs.data) {
                log.debug("subadmins", rawResult.ocs.data);
                rawResult.ocs.data.forEach((value) => {
                    userIds.push(value);
                });
            }
            return userIds;
        });
    }
    /**
     * create a new user group
     * @async
     * @param {string} id user group id
     * @returns {Promise<UserGroup>}
     * @throws {UserGroupAlreadyExistsError}
     */
    createUserGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("createUserGroup id=", id);
            const requestInit = {
                body: JSON.stringify({ groupid: id }),
                headers: this.getOcsHeaders(),
                method: "POST",
            };
            log.debug("request body: ", requestInit.body);
            const response = yield this.getHttpResponse(this.getOcsUrl(`/groups`), requestInit, [200], { description: "UserGroup create" });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 102) {
                throw new error_1.UserGroupAlreadyExistsError(`User Group ${id} already exists`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return new userGroup_1.default(this, id);
            }
            throw new error_1.OperationFailedError(`User group ${id} could not be created: ${this.getOcsMetaStatus(rawResult).message}`);
        });
    }
    /**
     * deletes an existing user group
     * @param id string
     * @returns {Promise<void>}
     * @throws {UserGroupDowsNotExistError}
     * @throws {UserGroupDeletionFailedError}
     */
    deleteUserGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("deleteUserGroup id=", id);
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "DELETE",
            };
            log.debug("request body: ", requestInit.body);
            const response = yield this.getHttpResponse(this.getOcsUrl(`/groups/${id}`), requestInit, [200], { description: "UserGroup delete" });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 101) {
                throw new error_1.UserGroupDoesNotExistError(`User Group ${id} does not exists`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 102) {
                throw new error_1.UserGroupDeletionFailedError(`User Group ${id} could not be deleted`);
            }
        });
    }
    // ***************************************************************************************
    // user
    // spec: https://docs.nextcloud.com/server/latest/admin_manual/configuration_user/instruction_set_for_users.html
    // ***************************************************************************************
    /**
     * returns a list of users
     * https://docs.nextcloud.com/server/latest/admin_manual/configuration_user/instruction_set_for_users.html#search-get-users
     * @param search string
     * @param limit number
     * @param offset number
     */
    getUsers(search, limit, offset) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getUsers");
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            let url = this.getOcsUrl(`/users`);
            const queryParameter = [];
            if (search) {
                queryParameter.push(`search=${search}`);
            }
            if (limit) {
                if (limit < 1) {
                    throw new error_1.QueryLimitError("The limit must be larger than 0");
                }
                queryParameter.push(`limit=${limit}`);
            }
            if (offset) {
                if (offset < 1) {
                    throw new error_1.QueryOffsetError("The offset must be larger than 0");
                }
                queryParameter.push(`offset=${offset}`);
            }
            if (queryParameter.join("&").length > 1) {
                url += "?" + queryParameter.join("&");
            }
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: "Users get" });
            const rawResult = yield response.json();
            /*
            {
              ocs: {
                meta: {
                  status: 'ok',
                  statuscode: 100,
                  message: 'OK',
                  totalitems: '',
                  itemsperpage: ''
                },
                data: { users: ["u1", "u2"] }
              }
            }
            */
            const users = [];
            if (rawResult.ocs &&
                rawResult.ocs.data &&
                rawResult.ocs.data.users) {
                log.debug("user ids", rawResult.ocs.data.users);
                rawResult.ocs.data.users.forEach((value) => {
                    users.push(new user_1.default(this, value));
                });
            }
            return users;
        });
    }
    /**
     * returns user data
     * @param id string the user id
     * @returns Promise<IUserOptions> user data
     * @throws {UserNotFoundError}
     */
    getUserData(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getUserData");
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const url = this.getOcsUrl(`/users/${id}`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: `User ${id} get` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 404) {
                throw new error_1.UserNotFoundError(`User '${id}' not found`);
            }
            /*
            {
              ocs: {
                meta: {
                  status: 'ok',
                  statuscode: 100,
                  message: 'OK',
                  totalitems: '',
                  itemsperpage: ''
                },
                data: { ... }
              }
            }
            */
            let userData;
            log.debug("user data", rawResult.ocs.data);
            userData = {
                enabled: rawResult.ocs.data.enabled,
                lastLogin: rawResult.ocs.data.lastLogin === 0 ? undefined : new Date(rawResult.ocs.data.lastLogin),
                subadminGroups: rawResult.ocs.data.subadmin,
                memberGroups: rawResult.ocs.data.groups,
                quota: {
                    free: 0,
                    used: 0,
                    total: 0,
                    relative: 0,
                    quota: 0
                },
                email: rawResult.ocs.data.email,
                displayName: rawResult.ocs.data.displayname,
                phone: rawResult.ocs.data.phone,
                address: rawResult.ocs.data.address,
                website: rawResult.ocs.data.website,
                twitter: rawResult.ocs.data.twitter,
                language: rawResult.ocs.data.language,
                locale: rawResult.ocs.data.locale,
            };
            if (rawResult.ocs.data.quota.quota === 'none') {
                userData.quota = { quota: 0, relative: 0, used: 0 };
            }
            else {
                if (!rawResult.ocs.data.quota.relative) {
                    rawResult.ocs.data.quota.relative = 0;
                }
                userData.quota = { quota: rawResult.ocs.data.quota.quota, relative: rawResult.ocs.data.quota.relative, used: rawResult.ocs.data.quota.used };
                if (rawResult.ocs.data.quota.free) {
                    userData.quota.free = rawResult.ocs.data.quota.free;
                }
                if (rawResult.ocs.data.quota.total) {
                    userData.quota.total = rawResult.ocs.data.quota.total;
                }
            }
            return userData;
        });
    }
    /**
     * enables the user
     * @param id string the user id
     * @returns {Promise<void>}
     * @throws {UserNotFoundError}
     */
    enableUser(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("enableUser");
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "PUT",
            };
            const url = this.getOcsUrl(`/users/${id}/enable`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: `User ${id} enable` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return;
            }
            throw new error_1.UserNotFoundError(`User '${id}' not found`);
        });
    }
    /**
     * disables the user
     * @param id string the user id
     * @returns {Promise<void>}
     * @throws {UserNotFoundError}
     */
    disableUser(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("disableUser");
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "PUT",
            };
            const url = this.getOcsUrl(`/users/${id}/disable`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: `User ${id} disable` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return;
            }
            throw new error_1.UserNotFoundError(`User '${id}' not found`);
        });
    }
    /**
     * deletes the user
     * @param id string the user id
     * @returns {Promise<void>}
     * @throws {UserNotFoundError}
     */
    deleteUser(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("deleteUser");
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "DELETE",
            };
            const url = this.getOcsUrl(`/users/${id}`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: `User ${id} delete` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return;
            }
            throw new error_1.UserNotFoundError(`User '${id}' not found`);
        });
    }
    /**
     * returns a user or null if not found
     * @param id string
     * @returns User | null
     */
    getUser(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("getUser");
            const users = yield this.getUsers(id);
            if (users[0]) {
                return users[0];
            }
            return null;
        });
    }
    /**
     * creates a new user with email or password
     * @param options
     * @returns User
     * @throws UserAlreadyExistsError
     * @throws {UserNotFoundError}
     * @throws UserUpdateError
     */
    createUser(options) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("createUser");
            const createUserBody = { userid: options.id };
            if (options.email) {
                if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(options.email)) {
                    createUserBody.email = options.email;
                }
                else {
                    throw new error_1.UserCreateError(`Error creating user '${options.id}' - invalid email address '${options.email}'`);
                }
            }
            if (options.password) {
                createUserBody.password = options.password;
            }
            const requestInit = {
                body: JSON.stringify(createUserBody, null, 4),
                headers: this.getOcsHeaders(),
                method: "POST",
            };
            log.debug("request body: ", requestInit.body);
            const response = yield this.getHttpResponse(this.getOcsUrl(`/users`), requestInit, [200], { description: `User ${options.id} create` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 102) {
                throw new error_1.UserAlreadyExistsError(`User with id '${options.id}' already exists`);
            }
            const user = yield this.getUser(options.id);
            if (user) {
                return user;
            }
            throw new error_1.UserCreateError(`Error creating user '${options.id}' - ${this.getOcsMetaStatus(rawResult).message} (${this.getOcsMetaStatus(rawResult).code})`);
        });
    }
    /**
     * updates a user property
     * @async
     * @param {string} id user id
     * @param {UserProperty} property property name
     * @param {string} value property value
     * @returns {Promise<void>}
     * @throws  {UserNotFoundError}
     * @throws  {UserUpdateError}
     */
    updateUserProperty(id, property, value) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("updateUserProperty");
            const body = { key: property, value };
            const requestInit = {
                body: JSON.stringify(body, null, 4),
                headers: this.getOcsHeaders(),
                method: "PUT",
            };
            const url = this.getOcsUrl(`/users/${id}`);
            log.debug("request body: ", requestInit.body);
            const response = yield this.getHttpResponse(url, requestInit, [200, 401], { description: `User ${id} update ${property}=${value}` });
            const rawResult = yield response.json();
            // This service operation returns a 401, if the user does not exist - very strange...
            // spec says to return 200 and status code 101
            /*
            if (this.getOcsMetaStatus(rawResult).code === 101) {
                throw new UserNotFoundError(`User with id '${id}' not found`);
            }
            */
            // maybe this is due to a nextcloud api error
            // it is not possible to distiguish beteen authentication error and user not found :-(
            if (response.status === 401) {
                throw new error_1.UserNotFoundError(`User with id '${id}' not found`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return;
            }
            if (property === user_1.UserProperty.password) {
                value = "********";
            }
            // code 102 or 103
            throw new error_1.UserUpdateError(`User with id '${id}' could not be updated - ${property}=${value}. ${rawResult.ocs.meta.message}`);
        });
    }
    /**
     * resend the welcome email
     * @param id user id
     * @throws  {UserResendWelcomeEmailError}
     */
    resendWelcomeEmail(id) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("resendWelcomeEmail");
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "POST",
            };
            const url = this.getOcsUrl(`/users/${id}/welcome`);
            log.debug("request body: ", requestInit.body);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: `Resend welcome email for user ${id}` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 101) {
                throw new error_1.UserResendWelcomeEmailError(`Error sending welcome email for '${id}': Email address not available`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return;
            }
            throw new error_1.UserResendWelcomeEmailError(`Error sending welcome email for '${id}' failed`);
        });
    }
    /**
     * adds a user to a group as member
     * @param id string the user id
     * @param userGroupId string the user group id
     * @returns {Promise<void>}
     * @throws {UserNotFoundError}
     * @throws {UserGroupDoesNotExistError}
     * @throws {InsufficientPrivilegesError}
     * @throws {OperationFailedError}
     */
    addUserToMemberUserGroup(id, userGroupId) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("addUserToUserGroup");
            const body = { groupid: userGroupId };
            const requestInit = {
                body: JSON.stringify(body, null, 4),
                headers: this.getOcsHeaders(),
                method: "POST",
            };
            const url = this.getOcsUrl(`/users/${id}/groups`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: `Add user ${id} to user group ${userGroupId}` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return;
            }
            if (this.getOcsMetaStatus(rawResult).code === 102) {
                throw new error_1.UserGroupDoesNotExistError(`User group ${userGroupId} does not exist`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 103) {
                throw new error_1.UserNotFoundError(`User ${id} does not exist`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 104) {
                throw new error_1.InsufficientPrivilegesError(`Insufficient privileges to add a user to a group`);
            }
            throw new error_1.OperationFailedError(`User ${id} could not be added to user group ${userGroupId}: ${this.getOcsMetaStatus(rawResult).message}`);
        });
    }
    /**
     * removes a user from a group as member
     * @param id string the user id
     * @param userGroupId string the user group id
     * @returns {Promise<void>}
     * @throws {UserNotFoundError}
     * @throws {UserGroupDoesNotExistError}
     * @throws {InsufficientPrivilegesError}
     * @throws {OperationFailedError}
     */
    removeUserFromMemberUserGroup(id, userGroupId) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("removeUserFromMemberUserGroup");
            const body = { groupid: userGroupId };
            const requestInit = {
                body: JSON.stringify(body, null, 4),
                headers: this.getOcsHeaders(),
                method: "DELETE",
            };
            const url = this.getOcsUrl(`/users/${id}/groups`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: `Remove user ${id} from user group ${userGroupId}` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return;
            }
            if (this.getOcsMetaStatus(rawResult).code === 102) {
                throw new error_1.UserGroupDoesNotExistError(`User group ${userGroupId} does not exist`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 103) {
                throw new error_1.UserNotFoundError(`User ${id} does not exist`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 104) {
                throw new error_1.InsufficientPrivilegesError(`Insufficient privileges to add a user to a group`);
            }
            throw new error_1.OperationFailedError(`User ${id} could not be added to user group ${userGroupId}: ${this.getOcsMetaStatus(rawResult).message}`);
        });
    }
    /**
     * promotes a user to a user group subadmin
     * @param id string the user id
     * @param userGroupId string the user group id
     * @returns {Promise<void>}
     * @throws {UserNotFoundError}
     * @throws {UserGroupDoesNotExistError}
     * @throws {InsufficientPrivilegesError}
     * @throws {OperationFailedError}
     */
    promoteUserToUserGroupSubadmin(id, userGroupId) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("promoteUserToUserGroupSubadmin");
            const body = { groupid: userGroupId };
            const requestInit = {
                body: JSON.stringify(body, null, 4),
                headers: this.getOcsHeaders(),
                method: "POST",
            };
            const url = this.getOcsUrl(`/users/${id}/subadmins`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: `Promote User ${id} to user group subadmin ${userGroupId}` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return;
            }
            if (this.getOcsMetaStatus(rawResult).code === 102) {
                throw new error_1.UserGroupDoesNotExistError(`User group ${userGroupId} does not exist`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 101) {
                throw new error_1.UserNotFoundError(`User ${id} does not exist`);
            }
            if (this.getOcsMetaStatus(rawResult).code === 104) {
                throw new error_1.InsufficientPrivilegesError(`Insufficient privileges to add a user to a group`);
            }
            throw new error_1.OperationFailedError(`User ${id} could not be removed from user group ${userGroupId}: ${this.getOcsMetaStatus(rawResult).message}`);
        });
    }
    /**
     * Removes the subadmin rights for the user specified from the group specified
     * @param id string the user id
     * @param userGroupId string the user group id
     * @returns {Promise<void>}
     * @throws {InsufficientPrivilegesError}
     * @throws {OperationFailedError}
     */
    demoteUserFromSubadminUserGroup(id, userGroupId) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("demoteUserFromSubadminUserGroup");
            const body = { groupid: userGroupId };
            const requestInit = {
                body: JSON.stringify(body, null, 4),
                headers: this.getOcsHeaders(),
                method: "DELETE",
            };
            const url = this.getOcsUrl(`/users/${id}/subadmins`);
            log.debug("url ", url);
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: `Demotes user ${id} from subadmin user group ${userGroupId}` });
            const rawResult = yield response.json();
            if (this.getOcsMetaStatus(rawResult).code === 100) {
                return;
            }
            // this API does not work like remove from group :-(
            // 101 is for user group not found and user not found
            /*
                if (this.getOcsMetaStatus(rawResult).code === 101) {
                    throw new UserGroupDoesNotExistError(`User group ${userGroupId} does not exist`)
                }
    
                if (this.getOcsMetaStatus(rawResult).code === 101) {
                    throw new UserNotFoundError(`User ${id} does not exist`)
                }
            */
            if (this.getOcsMetaStatus(rawResult).code === 104) {
                throw new error_1.InsufficientPrivilegesError(`Insufficient privileges to add a user to a group`);
            }
            throw new error_1.OperationFailedError(`User ${id} could not be demoted from subadmin user group ${userGroupId}: ${this.getOcsMetaStatus(rawResult).message}`);
        });
    }
    /**
     * insert or update complete user data
     * @param options IUpsertUserOptions[]
     * @returns Promise<IUpsertUserReport[]
     */
    upsertUsers(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const report = [];
            for (const option of options) {
                const userReport = { id: option.id, message: "", changes: [] };
                let user = yield this.getUser(option.id);
                // create or update user?
                if (!user) {
                    try {
                        user = yield this.createUser({ id: option.id, email: option.email, password: option.password });
                        userReport.message = `User ${option.id} created`;
                    }
                    catch (e) {
                        userReport.message = `Create user ${option.id} failed ${e.message}`;
                        report.push(userReport);
                        continue;
                    }
                }
                else {
                    userReport.message = `User ${option.id} changed`;
                }
                let previousValue = "";
                let newValue = "";
                let property = "";
                // ************************
                // enabled
                // ************************
                if (option.enabled !== undefined) {
                    if ((yield user.isEnabled()) && option.enabled === false) {
                        try {
                            yield user.disable();
                            userReport.changes.push({ property: "enabled", previousValue: "true", newValue: "false" });
                        }
                        catch (e) {
                            userReport.changes.push({ property: "enabled", previousValue: "true", newValue: "true", error: e.message });
                        }
                    }
                    if ((yield user.isEnabled()) === false && option.enabled === true) {
                        try {
                            yield user.enable();
                            userReport.changes.push({ property: "enabled", previousValue: "false", newValue: "true" });
                        }
                        catch (e) {
                            userReport.changes.push({ property: "enabled", previousValue: "false", newValue: "false", error: e.message });
                        }
                    }
                }
                // ************************
                // super admin
                // ************************
                if (option.superAdmin !== undefined) {
                    if ((yield user.isSuperAdmin()) && option.superAdmin === false) {
                        try {
                            yield user.demoteFromSuperAdmin();
                            userReport.changes.push({ property: "superAdmin", previousValue: "true", newValue: "false" });
                        }
                        catch (e) {
                            userReport.changes.push({ property: "superAdmin", previousValue: "true", newValue: "true", error: e.message });
                        }
                    }
                    if ((yield user.isSuperAdmin()) === false && option.superAdmin === true) {
                        try {
                            yield user.promoteToSuperAdmin();
                            userReport.changes.push({ property: "superAdmin", previousValue: "false", newValue: "true" });
                        }
                        catch (e) {
                            userReport.changes.push({ property: "superAdmin", previousValue: "false", newValue: "false", error: e.message });
                        }
                    }
                }
                // ************************
                // member groups
                // ************************
                if (option.memberGroups !== undefined) {
                    const previousGroups = yield user.getMemberUserGroupIds();
                    const newGroups = option.memberGroups;
                    if (option.superAdmin !== undefined) {
                        if (option.superAdmin === true) {
                            if (newGroups.indexOf("admin") === -1) {
                                newGroups.push("admin");
                            }
                        }
                    }
                    const groupsToAdd = newGroups.filter(x => !previousGroups.includes(x));
                    const groupsToRemove = previousGroups.filter(x => !newGroups.includes(x));
                    let userGroup;
                    property = "memberGroups";
                    let error = null;
                    for (const groupId of groupsToAdd) {
                        userGroup = yield this.getUserGroup(groupId);
                        if (!userGroup) {
                            try {
                                userGroup = yield this.createUserGroup(groupId);
                            }
                            catch (e) {
                                error = e;
                                break;
                            }
                        }
                        try {
                            yield user.addToMemberUserGroup(userGroup);
                        }
                        catch (e) {
                            error = e;
                            break;
                        }
                    }
                    for (const groupId of groupsToRemove) {
                        try {
                            yield user.removeFromMemberUserGroup(new userGroup_1.default(this, groupId));
                        }
                        catch (e) {
                            error = e;
                            break;
                        }
                    }
                    if (error) {
                        userReport.changes.push({ property, previousValue: previousGroups.join(", "), newValue: previousGroups.join(", "), error: error.message });
                    }
                    else {
                        if (groupsToAdd.length > 0 || groupsToRemove.length > 0) {
                            userReport.changes.push({ property, previousValue: previousGroups.join(", "), newValue: newGroups.join(", ") });
                        }
                    }
                }
                // ************************
                // subadmin groups
                // ************************
                if (option.subadminGroups !== undefined) {
                    const previousGroups = yield user.getSubadminUserGroupIds();
                    const newGroups = option.subadminGroups;
                    const groupsToAdd = newGroups.filter(x => !previousGroups.includes(x));
                    const groupsToRemove = previousGroups.filter(x => !newGroups.includes(x));
                    let userGroup;
                    property = "subadminGroups";
                    let error = null;
                    for (const groupId of groupsToAdd) {
                        userGroup = yield this.getUserGroup(groupId);
                        if (!userGroup) {
                            try {
                                userGroup = yield this.createUserGroup(groupId);
                            }
                            catch (e) {
                                error = e;
                                break;
                            }
                        }
                        try {
                            yield user.promoteToUserGroupSubadmin(userGroup);
                        }
                        catch (e) {
                            error = e;
                            break;
                        }
                    }
                    for (const groupId of groupsToRemove) {
                        try {
                            yield user.demoteFromSubadminUserGroup(new userGroup_1.default(this, groupId));
                        }
                        catch (e) {
                            error = e;
                            break;
                        }
                    }
                    if (error) {
                        userReport.changes.push({ property, previousValue: previousGroups.join(", "), newValue: previousGroups.join(", "), error: error.message });
                    }
                    else {
                        userReport.changes.push({ property, previousValue: previousGroups.join(", "), newValue: newGroups.join(", ") });
                    }
                }
                // ************************
                // display name
                // ************************
                if (option.displayName !== undefined) {
                    previousValue = yield user.getDisplayName();
                    newValue = option.displayName;
                    property = "displayName";
                    if (previousValue !== newValue) {
                        try {
                            yield user.setDisplayName(option.displayName);
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                // ************************
                // email
                // ************************
                if (option.email !== undefined) {
                    previousValue = yield user.getEmail();
                    newValue = option.email;
                    property = "email";
                    if (previousValue !== newValue) {
                        try {
                            yield user.setEmail(option.email);
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                // ************************
                // language
                // ************************
                if (option.language !== undefined) {
                    previousValue = yield user.getLanguage();
                    newValue = option.language;
                    property = "language";
                    if (previousValue !== newValue) {
                        try {
                            yield user.setLanguage(option.language);
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                // ************************
                // locale
                // ************************
                if (option.locale !== undefined) {
                    previousValue = yield user.getLocale();
                    newValue = option.locale;
                    property = "locale";
                    if (previousValue !== newValue) {
                        try {
                            yield user.setLocale(option.locale);
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                // ************************
                // twitter
                // ************************
                if (option.twitter !== undefined) {
                    previousValue = yield user.getTwitter();
                    newValue = option.twitter;
                    property = "twitter";
                    if (previousValue !== newValue) {
                        try {
                            yield user.setTwitter(option.twitter);
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                // ************************
                // phone
                // ************************
                if (option.phone !== undefined) {
                    previousValue = yield user.getPhone();
                    newValue = option.phone;
                    property = "phone";
                    if (previousValue !== newValue) {
                        try {
                            yield user.setPhone(option.phone);
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                // ************************
                // password
                // ************************
                if (option.password !== undefined) {
                    previousValue = "********";
                    newValue = option.password;
                    property = "password";
                    try {
                        yield user.setPassword(option.password);
                        userReport.changes.push({ property, previousValue, newValue: previousValue });
                    }
                    catch (e) {
                        userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                    }
                }
                // ************************
                // address
                // ************************
                if (option.address !== undefined) {
                    previousValue = yield user.getAddress();
                    newValue = option.address;
                    property = "address";
                    if (previousValue !== newValue) {
                        try {
                            yield user.setAddress(option.address);
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                // ************************
                // website
                // ************************
                if (option.website !== undefined) {
                    previousValue = yield user.getWebsite();
                    newValue = option.website;
                    property = "website";
                    if (previousValue !== newValue) {
                        try {
                            yield user.setWebsite(option.website);
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                // ************************
                // quota
                // ************************
                if (option.quota !== undefined) {
                    previousValue = yield (yield user.getQuotaUserFriendly()).quota;
                    newValue = option.quota;
                    property = "quota";
                    if (previousValue !== newValue) {
                        try {
                            yield user.setQuota(option.quota);
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                // ************************
                // resend welcome email
                // ************************
                if (option.resendWelcomeEmail !== undefined) {
                    previousValue = "not sent";
                    newValue = "sent";
                    property = "resendWelcomeEmail";
                    if (option.resendWelcomeEmail) {
                        try {
                            yield user.resendWelcomeEmail();
                            userReport.changes.push({ property, previousValue, newValue });
                        }
                        catch (e) {
                            userReport.changes.push({ property, previousValue, newValue: previousValue, error: e.message });
                        }
                    }
                }
                if (userReport.changes.length === 0) {
                    userReport.message = `User ${option.id} not changed`;
                }
                report.push(userReport);
            }
            return report;
        });
    }
    // ***************************************************************************************
    // shares
    // https://docs.nextcloud.com/server/latest/developer_manual/client_apis/OCS/ocs-share-api.html
    // ***************************************************************************************
    /**
     * create a new share
     */
    createShare(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const shareRequest = share_1.default.createShareRequestBody(options);
            log.debug(shareRequest);
            const requestInit = {
                body: shareRequest,
                headers: this.getOcsHeaders(),
                method: "POST",
            };
            const url = this.nextcloudOrigin + "/ocs/v2.php/apps/files_sharing/api/v1/shares";
            // try {
            const response = yield this.getHttpResponse(url, requestInit, [200, 204], { description: "Share create" });
            const rawResult = yield response.json();
            log.debug(rawResult);
            const share = yield share_1.default.getShare(this, rawResult.ocs.data.id);
            if (options.publicUpload) {
                yield share.setPublicUpload();
            }
            return share;
            /* } catch (e) {
                log.debug("result " + e.message);
                log.debug("requestInit ", JSON.stringify(requestInit, null, 4));
                log.debug("headers " + JSON.stringify(headers, null, 4));
                log.debug("url ", url);
                throw e;
            } */
        });
    }
    /**
     * update a new share
     */
    updateShare(shareId, body) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("updateShare body ", body);
            const requestInit = {
                body: JSON.stringify(body, null, 4),
                headers: this.getOcsHeaders(),
                method: "PUT",
            };
            const url = this.nextcloudOrigin + "/ocs/v2.php/apps/files_sharing/api/v1/shares/" + shareId;
            yield this.getHttpResponse(url, requestInit, [200], { description: "Share update" });
        });
    }
    /**
     * get share information
     * @param shareId
     */
    getShare(shareId) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const url = this.nextcloudOrigin + "/ocs/v2.php/apps/files_sharing/api/v1/shares/" + shareId;
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: "Share get" });
            const rawResult = yield response.json();
            return rawResult;
            /*
        } catch (e) {
            log.debug("result " + e.message);
            log.debug("requestInit ", JSON.stringify(requestInit, null, 4));
            log.debug("headers " + JSON.stringify(headers, null, 4));
            log.debug("url ", url);
            throw e;
        }
        */
        });
    }
    /**
     * get share information
     * @param shareId
     */
    deleteShare(shareId) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "DELETE",
            };
            const url = this.nextcloudOrigin + "/ocs/v2.php/apps/files_sharing/api/v1/shares/" + shareId;
            const response = yield this.getHttpResponse(url, requestInit, [200], { description: "Share delete" });
        });
    }
    // ***************************************************************************************
    // notfication management
    // ***************************************************************************************
    /**
     * @returns array of notification objects
     */
    getNotifications() {
        return __awaiter(this, void 0, void 0, function* () {
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const response = yield this.getHttpResponse(this.nextcloudOrigin + "/ocs/v2.php/apps/notifications/api/v2/notifications", requestInit, [200, 404], { description: "Notifications get" });
            // no notification found
            if (response.status === 404) {
                return [];
            }
            const rawResult = yield response.json();
            let notifications = [];
            if (rawResult && rawResult.ocs && rawResult.ocs.data) {
                notifications = rawResult.ocs.data;
            }
            else {
                throw new error_1.default("Fatal Error: nextcloud notifications data missing", "ERR_SYSTEM_INFO_MISSING_DATA"); // @todo wrong error message
            }
            const result = notifications;
            return result;
        });
    }
    getUpdateNotifications(version) {
        return __awaiter(this, void 0, void 0, function* () {
            // @todo refactoring... /ocs/v2.php/apps/notifications/api/v2/notifications/<id>   (GET/DELETE)
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const response = yield this.getHttpResponse(this.nextcloudOrigin + `/ocs/v2.php/apps/updatenotification/api/v1/applist/${version}`, requestInit, [200], { description: "UpdateNotifications get" });
            const rawResult = yield response.json();
            let updateNotification = {};
            if (rawResult && rawResult.ocs && rawResult.ocs.data) {
                updateNotification = rawResult.ocs.data;
            }
            else {
                throw new error_1.default("Fatal Error: nextcloud notifications data missing", "ERR_SYSTEM_INFO_MISSING_DATA");
            }
            const result = updateNotification;
            return result;
        });
    }
    // @todo to be refactored to user
    sendNotificationToUser(userId, shortMessage, longMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestInit = {
                headers: new node_fetch_1.Headers({
                    "Accept": "application/json",
                    "Content-Type": "application/x-www-form-urlencoded",
                    "OCS-APIRequest": "true",
                }),
                method: "POST",
            };
            if (!longMessage) {
                longMessage = "";
            }
            longMessage = `&longMessage=${encodeURIComponent(longMessage)}`;
            const queryString = `${encodeURIComponent(userId)}?shortMessage=${encodeURIComponent(shortMessage)}${longMessage}`;
            const response = yield this.getHttpResponse(this.nextcloudOrigin + `/ocs/v2.php/apps/admin_notifications/api/v1/notifications/${queryString}`, requestInit, [200], { description: "User create" });
            const rawResult = yield response.json();
            //        console.log(rawResult);
        });
    }
    // ***************************************************************************************
    // apps management
    // ***************************************************************************************
    /**
     * returns apps
     */
    getApps() {
        return __awaiter(this, void 0, void 0, function* () {
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const response = yield this.getHttpResponse(this.getOcsUrl(`/apps`), requestInit, [200], { description: "Apps get" });
            const rawResult = yield response.json();
            let apps = [];
            if (rawResult && rawResult.ocs && rawResult.ocs.data) {
                apps = rawResult.ocs.data;
            }
            else {
                throw new error_1.default("Fatal Error: nextcloud apps data missing", "ERR_SYSTEM_INFO_MISSING_DATA");
            }
            const result = apps;
            return result;
        });
    }
    getAppInfos(appName) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestInit = {
                headers: this.getOcsHeaders(),
                method: "GET",
            };
            const response = yield this.getHttpResponse(this.getOcsUrl(`/apps/${appName}`), requestInit, [200], { description: "App Infos get" });
            const rawResult = yield response.json();
            let appInfo = {};
            if (rawResult && rawResult.ocs && rawResult.ocs.data) {
                appInfo = rawResult.ocs.data;
            }
            else {
                throw new error_1.default("Fatal Error: nextcloud apps data missing", "ERR_SYSTEM_INFO_MISSING_DATA");
            }
            const result = appInfo;
            return result;
        });
    }
    // ***************************************************************************************
    // private methods
    // ***************************************************************************************
    /**
     * asserts valid xml
     * asserts multistatus response
     * asserts that a href is available in the multistatus response
     * asserts propstats and prop
     * @param response the http response
     * @param href get only properties that match the href
     * @returns array of properties
     * @throws GeneralError
     */
    getPropertiesFromWebDAVMultistatusResponse(response, href) {
        return __awaiter(this, void 0, void 0, function* () {
            const responseContentType = response.headers.get("Content-Type");
            if (!responseContentType) {
                throw new error_1.default("Response content type expected", "ERR_RESPONSE_WITHOUT_CONTENT_TYPE_HEADER");
            }
            if (responseContentType.indexOf("application/xml") === -1) {
                throw new error_1.default("XML response content type expected", "ERR_XML_RESPONSE_CONTENT_TYPE_EXPECTED");
            }
            const xmlBody = yield response.text();
            if (fast_xml_parser_1.default.validate(xmlBody) !== true) {
                throw new error_1.default(`The response is not valid XML: ${xmlBody}`, "ERR_RESPONSE_NOT_INVALID_XML");
            }
            const options = {
                ignoreNameSpace: true,
            };
            const body = fast_xml_parser_1.default.parse(xmlBody, options);
            // ensure that we have a multistatus response
            if (!body.multistatus || !body.multistatus.response) {
                throw new error_1.default(`The response is is not a WebDAV multistatus response`, "ERR_RESPONSE_NO_MULTISTATUS_XML");
            }
            // ensure that response is always an array
            if (body.multistatus.response.href || body.multistatus.response.propstat) {
                body.multistatus.response = new Array(body.multistatus.response);
            }
            /*
                    if (body.multistatus.response.propstat) {
                        body.multistatus.response = [body.multistatus.response];
                    }
            */
            const responseProperties = [];
            for (const res of body.multistatus.response) {
                if (!res.href) {
                    throw new error_1.default(`The mulitstatus response must have a href`, "ERR_RESPONSE_MISSING_HREF_MULTISTATUS");
                }
                if (!res.propstat) {
                    throw new error_1.default(`The mulitstatus response must have a "propstat" container`, "ERR_RESPONSE_MISSING_PROPSTAT");
                }
                let propStats = res.propstat;
                // ensure an array
                if (res.propstat.status || res.propstat.prop) {
                    propStats = [res.propstat];
                }
                for (const propStat of propStats) {
                    if (!propStat.status) {
                        throw new error_1.default(`The propstat must have a "status"`, "ERR_RESPONSE_MISSING_PROPSTAT_STATUS");
                    }
                    if (propStat.status === "HTTP/1.1 200 OK") {
                        if (!propStat.prop) {
                            throw new error_1.default(`The propstat must have a "prop"`, "ERR_RESPONSE_MISSING_PROPSTAT_PROP");
                        }
                        const property = propStat.prop;
                        property._href = res.href;
                        responseProperties.push(property);
                    }
                }
                //            }
            }
            return responseProperties;
        });
    }
    /**
     * nextcloud creates a csrf token and stores it in the html header attribute
     * data-requesttoken
     * this function is currently not used
     * @returns the csrf token / requesttoken
     */
    /*
        private async getCSRFToken(): Promise<string> {

            const requestInit: RequestInit = {
                method: "GET",
            };

            const response: Response = await this.getHttpResponse(
                this.nextcloudOrigin,
                requestInit,
                [200],
                { description: "CSER token get" });

            const html = await response.text();

            const requestToken: string = html.substr(html.indexOf("data-requesttoken=") + 19, 89);
            log.debug("getCSRFToken ", requestToken);
            return requestToken;
        }
    */
    getHttpResponse(url, requestInit, expectedHttpStatusCode, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!requestInit.headers) {
                requestInit.headers = new node_fetch_1.Headers();
            }
            /* istanbul ignore else */
            if (this.fakeServer) {
                return yield this.fakeServer.getFakeHttpResponse(url, requestInit, expectedHttpStatusCode, context);
            }
            else {
                return yield this.httpClient.getHttpResponse(url, requestInit, expectedHttpStatusCode, context);
            }
        });
    }
    /**
     * get contents array of a folder
     * @param folderName Name of the folder like "/company/branches/germany"
     * @param folderIndicator true if folders are requested otherwise files
     * @returns array of folder contents meta data
     */
    Contents(folderName, folderIndicator) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug("Contents: folder ", folderName);
            const folders = [];
            folderName = this.sanitizeFolderName(folderName);
            const resultArray = [];
            if (folderIndicator === true) {
                log.debug("Contents: get folders");
            }
            else {
                log.debug("Contents: get files");
            }
            try {
                const folderContentsArray = yield this.getFolderContents(folderName);
                // log.debug("###########################");
                // log.debug("$s", JSON.stringify(folderContentsArray, null, 4));
                // log.debug("###########################");
                for (const folderElement of folderContentsArray) {
                    if (folderElement.type === "directory") {
                        if (folderIndicator === true) {
                            resultArray.push(folderElement);
                        }
                    }
                    else {
                        if (folderIndicator === false) {
                            log.debug("Contents folder element file ", folderElement);
                            resultArray.push(folderElement);
                        }
                    }
                }
            }
            catch (e) {
                log.debug("Contents: exception occurred ", e.message);
            }
            return resultArray;
        });
    }
    sanitizeFolderName(folderName) {
        if (folderName[0] !== "/") {
            folderName = "/" + folderName;
        }
        // remove trailing "/" es
        folderName = folderName.replace(/\/+$/, "");
        if (folderName === "") {
            folderName = "/";
        }
        return folderName;
    }
    getTagIdFromHref(href) {
        return parseInt(href.split("/")[href.split("/").length - 1], 10);
    }
    createFolderInternal(folderName) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.webDAVUrl + folderName;
            log.debug("createFolderInternal ", url);
            const requestInit = {
                method: "MKCOL",
            };
            try {
                yield this.getHttpResponse(url, requestInit, [201], { description: "Folder create" });
            }
            catch (err) {
                log.debug(`Error in createFolderInternal ${err.message} ${requestInit.method} ${url}`);
                throw err;
            }
        });
    }
    stat(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.webDAVUrl + fileName;
            log.debug("stat ", url);
            const requestInit = {
                body: `<?xml version="1.0"?>
            <d:propfind  xmlns:d="DAV:" xmlns:oc="http://owncloud.org/ns" xmlns:nc="http://nextcloud.org/ns">
            <d:prop>
                  <d:getlastmodified />
                  <d:getetag />
                  <d:getcontenttype />
                  <d:resourcetype />
                  <oc:fileid />
                  <oc:permissions />
                  <oc:size />
                  <d:getcontentlength />
                  <nc:has-preview />
                  <oc:favorite />
                  <oc:comments-unread />
                  <oc:owner-display-name />
                  <oc:share-types />
            </d:prop>
          </d:propfind>`,
                headers: new node_fetch_1.Headers({ Depth: "0" }),
                method: "PROPFIND",
            };
            let response;
            try {
                response = yield this.getHttpResponse(url, requestInit, [207], { description: "File/Folder get details" });
            }
            catch (err) {
                log.debug(`Error in stat ${err.message} ${requestInit.method} ${url}`);
                throw err;
            }
            const properties = yield this.getPropertiesFromWebDAVMultistatusResponse(response, "");
            let resultStat = null;
            for (const prop of properties) {
                resultStat = {
                    basename: path_1.basename(fileName),
                    fileid: prop.fileid,
                    filename: fileName,
                    lastmod: prop.getlastmodified,
                    type: "file",
                };
                if (prop.getcontentlength) {
                    resultStat.size = prop.getcontentlength;
                }
                else {
                    resultStat.type = "directory";
                }
                if (prop.getcontenttype) {
                    resultStat.mime = prop.getcontenttype;
                }
            }
            if (!resultStat) {
                log.debug("Error: response ", JSON.stringify(properties, null, 4));
                throw new error_1.default("Error getting status information from : " + url, "ERR_STAT");
            }
            return resultStat;
        });
    }
    getOcsMetaStatus(input) {
        let code;
        let message = "";
        if (input.ocs &&
            input.ocs.meta &&
            input.ocs.meta.statuscode) {
            code = input.ocs.meta.statuscode;
            if (input.ocs.meta.message) {
                message = input.ocs.meta.message;
            }
            return { code, message };
        }
        throw new error_1.InvalidServiceResponseFormatError("Fatal Error: The OCS meta status could not be retrieved from OCS response");
    }
    getOcsHeaders() {
        return new node_fetch_1.Headers({
            "OCS-APIRequest": "true",
            "Content-Type": "application/json",
            "Accept": "application/json"
        });
    }
    getOcsUrl(suffix) {
        /*
        if (!suffix) {
            suffix = "";
        }
        if (!suffix.startsWith("/")) {
            suffix = `/${suffix}`
        }
        */
        return `${this.nextcloudOrigin}/ocs/v1.php/cloud${suffix}`;
    }
    putFileContents(fileName, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.webDAVUrl + fileName;
            log.debug("putFileContents ", url);
            const requestInit = {
                body: data,
                method: "PUT",
            };
            let response;
            let description = "File save content ";
            if (data instanceof Buffer) {
                description += "from buffer";
            }
            else {
                description += "from stream";
            }
            response = yield this.getHttpResponse(url, requestInit, [201, 204], { description });
            return response;
        });
    }
}
exports.default = Client;
exports.Client = Client;
Client.webDavUrlPath = "/remote.php/webdav";

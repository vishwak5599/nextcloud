"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShareItemType = exports.SharePermission = void 0;
const client_1 = require("./client");
var SharePermission;
(function (SharePermission) {
    SharePermission[SharePermission["all"] = 31] = "all";
    SharePermission[SharePermission["read"] = 1] = "read";
    SharePermission[SharePermission["update"] = 2] = "update";
    SharePermission[SharePermission["create"] = 4] = "create";
    SharePermission[SharePermission["delete"] = 8] = "delete";
    SharePermission[SharePermission["share"] = 16] = "share";
})(SharePermission = exports.SharePermission || (exports.SharePermission = {}));
var ShareType;
(function (ShareType) {
    ShareType[ShareType["user"] = 0] = "user";
    ShareType[ShareType["group"] = 1] = "group";
    ShareType[ShareType["publicLink"] = 3] = "publicLink";
    ShareType[ShareType["email"] = 4] = "email";
})(ShareType || (ShareType = {}));
var ShareItemType;
(function (ShareItemType) {
    ShareItemType["file"] = "file";
    ShareItemType["folder"] = "folder";
})(ShareItemType = exports.ShareItemType || (exports.ShareItemType = {}));
class Share {
    constructor(client, id) {
        this.client = client;
        this.memento = {
            expiration: null,
            id,
            itemType: ShareItemType.file,
            note: "",
            token: "",
            url: "",
            publicUpload: false,
        };
    }
    static getShare(client, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const share = new Share(client, id);
            yield share.initialize();
            return share;
        });
    }
    static createShareRequestBody(createShare) {
        const shareType = ShareType.publicLink;
        const shareRequest = {
            path: createShare.fileSystemElement.name,
            //  @todo    permissions: 1,
            shareType,
        };
        if (createShare.password) {
            shareRequest.password = createShare.password;
        }
        return JSON.stringify(shareRequest, null, 4);
    }
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.deleteShare(this.memento.id);
        });
    }
    setExpiration(expiration) {
        return __awaiter(this, void 0, void 0, function* () {
            this.memento.expiration = expiration;
            yield this.client.updateShare(this.memento.id, { expireDate: expiration.toISOString().split("T")[0] });
        });
    }
    /**
     * set a new password
     * @param password
     */
    setPassword(password) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.updateShare(this.memento.id, { password });
        });
    }
    setPublicUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.memento.itemType === ShareItemType.folder) {
                this.memento.publicUpload = true;
                yield this.client.updateShare(this.memento.id, { permissions: 15 });
            }
        });
    }
    setNote(note) {
        return __awaiter(this, void 0, void 0, function* () {
            this.memento.note = note;
            yield this.client.updateShare(this.memento.id, { note });
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const rawShareData = yield this.client.getShare(this.memento.id);
            if (!rawShareData.ocs || !rawShareData.ocs.data[0]) {
                throw new client_1.ClientError(`Error invalid share data received "ocs.data" missing`, "ERR_INVALID_SHARE_RESPONSE");
            }
            if (!rawShareData.ocs.data[0].url) {
                throw new client_1.ClientError(`Error invalid share data received "url" missing`, "ERR_INVALID_SHARE_RESPONSE");
            }
            this.memento.url = rawShareData.ocs.data[0].url;
            if (!rawShareData.ocs.data[0].token) {
                throw new client_1.ClientError(`Error invalid share data received "token" missing`, "ERR_INVALID_SHARE_RESPONSE");
            }
            this.memento.token = rawShareData.ocs.data[0].token;
            if (!rawShareData.ocs.data[0].item_type) {
                throw new client_1.ClientError(`Error invalid share data received "item_type" missing`, "ERR_INVALID_SHARE_RESPONSE");
            }
            if (rawShareData.ocs.data[0].item_type === "file") {
                this.memento.itemType = ShareItemType.file;
            }
            else {
                this.memento.itemType = ShareItemType.folder;
            }
            if (rawShareData.ocs.data[0].expiration) {
                this.memento.expiration = new Date(rawShareData.ocs.data[0].expiration);
            }
            if (rawShareData.ocs.data[0].note) {
                this.memento.note = rawShareData.ocs.data[0].note;
            }
            // console.log(JSON.stringify(rawShareData, null, 4));
            // console.log(JSON.stringify(this, null, 4));
        });
    }
    /**
     * token
     * The token is readonly
     */
    get token() {
        return this.memento.token;
    }
    /**
     * share url
     * The share url is readonly
     */
    get url() {
        return this.memento.url;
    }
    /**
     * expiration
     * The expiration is readonly
     */
    get expiration() {
        return this.memento.expiration;
    }
    /**
     * note
     * The note is readonly
     */
    get note() {
        return this.memento.note;
    }
    /**
     * id
     * The id is readonly
     */
    get id() {
        return this.memento.id;
    }
    /**
     * returns true if the share akkows upload
     */
    get publicUpload() {
        return this.memento.publicUpload;
    }
    /**
     * item type
     * The type of the share item file or folder
     */
    get itemType() {
        return this.memento.itemType;
    }
}
exports.default = Share;

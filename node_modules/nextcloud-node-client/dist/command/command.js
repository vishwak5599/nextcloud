"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandStatus = void 0;
// tslint:disable-next-line:no-var-requires
const debug = require("debug").debug("Command");
const client_1 = require("../client");
/**
 * The potential states that a command can have.
 * When a command is created, the state is "initial"
 * When the execution has started, the status is "running"
 * When the execution has finsihed, the status can be "succes" or "failed"
 */
var CommandStatus;
(function (CommandStatus) {
    /**
     * When a command is created, the state is "initial"
     */
    CommandStatus["initial"] = "initial";
    /**
     * When the execution has started, the status is "running"
     */
    CommandStatus["running"] = "running";
    /**
     * After successful  execution of the command, the status is "success"
     */
    CommandStatus["success"] = "success";
    /**
     * After unsuccessfull execution of the command, the status is "failed"
     */
    CommandStatus["failed"] = "failed";
})(CommandStatus = exports.CommandStatus || (exports.CommandStatus = {}));
/**
 * The command class represents a potential long running activity.
 * This activity has been wrapped into an object to ease the tracking of the processing state.
 * Create a command with  receiver information, execute the command and check the status and progress.
 * Check the result when finsished.
 */
class Command {
    constructor(client) {
        this.client = client;
        this.status = CommandStatus.initial;
        this.percentCompleted = 0;
        this.resultMetaData = { messages: [], errors: [], timeElapsed: 0 };
    }
    /**
     * final execute the command
     * @async
     * @final
     * @returns {Promise<void>}
     */
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            debug("execute Command = " + this.constructor.name, this.status);
            if (this.isFinished()) {
                throw new client_1.CommandAlreadyExecutedError("Error: Command has already been executed. Command = " + this.constructor.name);
            }
            if (this.status === CommandStatus.initial) {
                const startTime = new Date();
                yield this.onExecute();
                this.resultMetaData.timeElapsed = new Date().getTime() - startTime.getTime();
            }
            // do nothing if already running
        });
    }
    /**
     * returns true, if the command has been finished
     * @returns {boolean}
     */
    isFinished() {
        if (this.status === CommandStatus.failed || this.status === CommandStatus.success) {
            return true;
        }
        return false;
    }
    /**
     * returns the status of the command
     * @returns {CommandStatus}
     */
    getStatus() {
        return this.status;
    }
    /**
     * returns the completion percentage of the command
     * @returns {number} percentage of completion
     */
    getPercentCompleted() {
        return this.percentCompleted;
    }
    /**
     * returns the result meta data of the command
     * @returns {null|any} the result of the command
     */
    getResultMetaData() {
        return this.resultMetaData;
    }
}
exports.default = Command;
